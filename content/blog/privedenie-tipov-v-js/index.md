---
title: "Приведение типов в JS"
date: "2018-03-16T15:02:43.00Z"
description: "Магия или простые правила?    > «Где отсутствует точное знание, там действуют догадки, а из десяти догадок девять — ошибки»   > "
---

<!--kg-card-begin: html--><h4>Магия или простые правила?</h4>
<figure>
<p><img data-width="929" data-height="359" src="https://cdn-images-1.medium.com/max/800/1*qLzx9tDMLoj2o9Hy15X8Fw.png"><br />
</figure>
<blockquote><p><em>«Где отсутствует точное знание, там действуют<br />догадки, а из десяти догадок девять — ошибки»</em></p></blockquote>
<blockquote><p>(с) Максим Горький</p></blockquote>
<p>Данный материал, в первую очередь, вам не только поможет пройти собеседования на позицию Frontend разработчика, но вам лично прояснит как же все-таки работает магия в JS и почему. Эта статья может сделать вашу жизнь js-программиста более легкой. Для затравки вот вам задачка:</p>
<pre><code><strong>const</strong> bool = <strong>new</strong> Boolean(false);<br></code><strong>if</strong> (bool) <strong>console</strong>.log(bool);<br><strong>if</strong> (bool == false) <strong>console</strong>.log(bool);</pre>
<p>Что выведет?</p>
<p>Забегая вперед, скажу что отработают оба условия, при этом везде будет вывод что-то типа Boolean{false}. Почему так? Плохой и непонятный JS? Да нет, JS очень даже хороший и понятный, просто нужно все это понять.</p>
<p>Вообще написание этого материала — это подготовка к одной хорошей и интересной теме, связанной с полиморфизмом и перегрузкой в JS. Но когда я писал статьи про перегрузку и полиморфизм понял, что есть много вещей, которые нужно объяснить до того, как расскажу про них иначе будет сложно. Поэтому будем идти по порядку.</p>
<p>Система преобразования типов в JS очень простая, хотя на первый взгляд этого и не скажешь. Она сильно отличается от других языков программирования — это факт, поэтому у многих программистов, пришедших из других языков программирования в JavaScript часто вызывает когнитивный диссонанс. Но если разобраться, то реально все просто. Нужно усвоить, что в JS есть всего 3 приведения типов:</p>
<ol>
<li>Строковое</li>
<li>Численное</li>
<li>Логическое</li>
</ol>
<p>Строковое преобразование происходит при необходимости представления чего-либо в виде строки. Тут все просто.</p>
<p>Численное преобразование происходит в математических выражениях, а также при сравнении.</p>
<p>Логическое преобразование — приведение к true и false, происходит в логическом контексте(например в условиях) и при применении логических операторов. Все значения, которые можно трактовать как пустые, становятся false: 0, undefined, null, NaN, пустая строка.</p>
<p>Все остальное, в том числе и любые объекты — true.</p>
<p>В JavaScript логическое преобразование особенно интересно своим сочетанием с численным.</p>
<p><em>Дабы не писать Boolean, я заменю его на двойное преобразование !! — но оно не меняет сути и поведения.</em></p>
<p>Пример такой двусмысленности (если не знать правил):</p>
<pre><strong>const</strong> a = 0;<br><strong>const</strong> b = ' 0 ';</pre>
<pre><strong>console</strong>.log(!!a, !!b); // false, true<br><strong>console</strong>.log(a == b); // true</pre>
<p>Значение a в логическом контексте false, так как 0 — интуитивно пустое значение, как писалось выше. Значение b не пустое в логическом контексте, так как содержит строку из 3х символов (2 пробела и 0).</p>
<p>А когда мы сравниваем 0 и “ 0 ”, то мы сравниваем их не в логическом контексте, а в численном, поэтому у нас получается такое сравнение с преобразованием типов:</p>
<pre>Number(0) == Number(" 0 ")</pre>
<p>Таким образом нужно всего лишь запомнить, что в JavaScript есть 3 типа преобразований:</p>
<ol>
<li>String() — приведение к строке в строковом контексте (например при конкатенации строк).</li>
<li>Number() — приведение к примитиву в численном контексте, включая унарный плюс (+value). Происходит при сравнении разных типов.</li>
<li>Boolean() — приведение к логическому типу в логическом контексте.</li>
</ol>
<p>Особым случаем является проверка на равенство таких специальных типов как Null и Undefined. Они равны только друг другу и неравны всему остальному. Это прописано в спецификации.</p>
<pre><strong>null == null</strong>           // true<br><strong>undefined == undefined</strong> // true<br><strong>undefined == null</strong>      // true<br><strong>null == undefined</strong>      // true</pre>
<p>Возвращаясь к нашей задаче, которая была описана выше, так почему же так отработает код?</p>
<p>Если вы внимательно прочли статью, то теперь можете сами объяснить это. Давайте сверимся. Было дано:</p>
<pre><code><strong>const</strong> bool = <strong>new</strong> Boolean(false);<br></code><strong>if</strong> (bool) <strong>console</strong>.log(bool);<br><strong>if</strong> (bool == false) <strong>console</strong>.log(bool);</pre>
<p>Мы используем класс Boolean, который создает не примитив, а объект — экземпляр класса Boolean. Для таких объектов в JS прописана своя модель обработки объектов в логическом контексте, о чем писалось выше. Если bool — это объект, то в логическом контексте, неважно что это за объект и от какого класса, он всегда будет приведен к true:</p>
<pre><strong>Boolean</strong>(bool) // = true<br>// поэтому<br><strong>if</strong> (bool) // = true</pre>
<p>И все логично и все подчиняется правилам. Никакой магии. При этом, если мы производим сравнение, то тут сработает численное сравнение, при котором будет вызван “магический” метод valueOf:</p>
<pre>bool.<strong>valueOf</strong>() == <strong>false</strong><br>// поэтому<br>bool == <strong>false </strong>// true<br><strong>if</strong> (bool == <strong>false</strong>) // true</pre>
<p>Про магические методы мы поговорим в следующей статье. И так, вы видите, что все логично и все подчиняется правилам. Никакой магии.</p>
<h3>Зачем это знать?</h3>
<p>Нет, не затем, чтобы проходить собеседования. Понимать, как устроен ваш язык программирования, как он работает и почему — это та отличительная черта настоящего профессионала программиста от ремесленника. Понимание таких особенностей, позволяет в разы сократить поиск и устранение ошибок. Позволяет не плеваться и говорить какой язык плохой, а делать вещи, которые изначально кажутся невозможными. Да банально для общего развития. Как говорил М.В. Ломоносов:</p>
<blockquote><p>“Математику уже за то учить надо, что она ум в порядок приводит”</p></blockquote>
<blockquote><p>(с) М.В. Ломоносов</p></blockquote>
<p>Если хотите быть профессионалом, вам стоит понимать, как устроен ваш инструмент. Это повышает вашу ценность. Но не обязательно, да.</p>
<!--kg-card-end: html--><h2 id="-">Продолжение</h2><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="/js-privedenie-tipov-i-magia-2/"><div class="kg-bookmark-content"><div class="kg-bookmark-title">Про приведение типов в JS и магию. Часть 2</div><div class="kg-bookmark-description">Что еще надо знать в 2019 году
&gt; «Где отсутствует точное знание, там действуют догадки,
а из десяти догадок девять — ошибки» Этот материал будет полезен тем, кто планирует проходить собеседования, так и
тем, кто уже работает с JS и хочет лучше его понять (и простить). В предыдущей статье про п…</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://tech.geekjob.ru/favicon.png"><span class="kg-bookmark-author">Александр Майоров</span><span class="kg-bookmark-publisher">Geekjob Tech</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://www.gravatar.com/avatar/8f8f604430a6a2116749fad87c9c86d5?s=250&amp;d=mm&amp;r=x"></div></a></figure>


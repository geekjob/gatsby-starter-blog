---
title: "Fun Python#8: Невероятный пайтон"
date: "2020-04-05T18:15:28.00Z"
description: "WTF Python? Задачки с собеседований Часто ругают JavaScript за непонятную магию, не менее чаще ругают PHP, но вот Python сейчас "
---

<h2 id="wtf-python-">WTF Python? Задачки с собеседований</h2><p>Часто ругают JavaScript за непонятную магию, не менее чаще ругают PHP, но вот Python сейчас переживает пик популярности и его все любят несмотря ни на что. Расскажу свой небольшой опыт, что у меня вызвало удивление в виде вопросов с собеседования.</p><!--kg-card-begin: html--><h3>Округления</h3>
<pre>
x = (<strong>round</strong>(8.5) — <strong>round</strong>(7.5))<br><strong>print</strong>(a) # = ?
</pre>
<p>Вопрос, чему будет равно x? Ноль или 1 ?</p>
<p>Задумались? Вот и я задумался. И в догоночку еще 2 варианта:</p>
<pre>x = (<strong>round</strong>(8.5) - 7)<br><strong>print</strong>(x) # = 1</pre>
<pre>x = (<strong>round</strong>(7.5) - 7)<br><strong>print</strong>(x) # = 1</pre>
<p>Вот тут вроде бы точно все логично? Но оказывается нет. У Python есть особенность в округлении и заключается она в том, что функция округления в языке работает не всегда так, как ожидается, а алгоритм может различаться в разных версиях. Оказывается в Python 3 используется банковское(бухгалтерское) округление — по правилам данного округления если за последней значащей цифрой стоит 5, то последнюю цифру увеличивают, если она нечетная и уменьшают, если четная.</p>
<pre>round(8.5) # = 8<br>round(7.5) # = 8</pre>
<p>В то время как у PHP:</p>
<pre>&lt;?php <br>$x = (<strong>round</strong>(8.5) - 7);<br><strong>print</strong>($x); # = 2 <br>
$x = (<strong>round</strong>(7.5) - 7);<br><strong>print</strong>($x); # = 1</pre>
<p>А у JS:</p>
<pre><strong>let</strong> x= Math.round(8.5) - 7<br>console.log(x) // = 2 <br><strong>let</strong> x = Math.round(7.5) - 7<br>console.log(x) // = 1</pre>
<p>Потому что в других языках используется арифметическое округление. У меня возникла только одна мысль в голове: WTF, почему в питоне взяли такой способ округления? Неужто ради датасаентистов-финансистов? Искренне удивлен.</p>
<h4>Объекты и переменные в Python</h4>
<p>Да тех кто не из мира Python, напомню, что в этом языке все есть объекты. Поэтому когда вы вызываете функцию id(от числа), то вы получаете адрес этого числа в памяти, хотя оно никуда не присвоено. А так же если вы выполните:</p>
<pre><strong>instance</strong>(1, <strong>object</strong>) # True</pre>
<p>т.е. даже примитивы — это объекты, каждый из которых содержит как минимум счётчик ссылок, тип и значение.</p>
<p>Но помимо того что все есть объекты, в Python нет переменных в привычном понимании как они есть в PHP, JS, C/C++, Go, Rust, etc…</p>
<p>В пайтоне есть имена! Это тоже частенько спрашивают на собеседованиях. Чаще всего имена в Python можно воспринимать в качестве переменных, но необходимо понимать разницу.</p>
<p>В других языках переменная — это поименованная, либо адресуемая иным способом область памяти, адрес которой можно использовать для осуществления доступа к данным и изменять значение в ходе выполнения программы.</p>
<p>Т.е. если вы создаете переменную (в C, PHP, JS) и присваиваете ей примитив, то происходит следующее:</p>
<ol>
<li>Выделение достаточного количества памяти для значения.</li>
<li>Присвоение этому месту в памяти значения.</li>
<li>Привязывание переменной, которая указывает на это значение.</li>
</ol>
<p>Если вы захотите изменить значение, присвоив другое, то произойдет перезаписывание предыдущего. Это означает, что переменная по своей сути изменяема (мутабельна). Адрес переменной останется прежней, но значение по адресу будет изменено. Для того, чтобы ссылаться на одну и ту же область памяти в зависимости от языка существуют ссылки и указатели. Например в PHP есть возможно указывать явно ссылки, а вот в JS есть ссылки, но они неявные и нужно знать правила, что объекты и массивы передаются по ссылкам (могу раскрыть эти тезисы в отдельной статье если интересно).</p>
<p>Если мы создаем новую переменную и присваиваем ей значение первой, то создается новая область памяти, в которую копируется значение первой. В виде кода поясняю:</p>
<pre>&lt;?php<br><br>$x = 8; # ячейка памяти со значением 8 на которое указывает наша переменная<br><br>$y = $x; # новая ячейка памяти, в которую скопировалось значение<br><br>$x = 4; # адрес тот же, но значение другое<br><br>$z = &amp;$x; # $z ссылается на область, на которую указывает $x</pre>
<p>Если очень простыми словами утрировано то как-то так.</p>
<p>В Python нет переменных, вместо этого есть имена. Вы можете использовать термин «переменная», однако на собеседовании к вам могут придраться. Когда в Python создается имя, происходит следующее:</p>
<ol>
<li>Создаётся PyObject.</li>
<li>Значению для PyObject’а присваивается typecode и присваивается значение.</li>
<li>Создаётся имя.</li>
<li>Имя указывает на новый PyObject, а счётчик ссылок увеличивается на +1</li>
</ol>
<p>PyObject владеет памятью, в которой живёт значение, а python-имя не владеет напрямую адресом в памяти.</p>
<p>Возвращаясь к началу абзаца мы и видим такое поведение:</p>
<pre>id(100) # PyObject 100 с адресом в памяти 0001<br>a = 100 # а - это имя для PyObject с адресом 0001</pre>
<pre>a = 101 # а - теперь является иеменем для PyObject 101, а у PyObject 100 счетчик ссылок уменьшился на -1</pre>
<p>Т.е. вроде бы похоже на переменные, но имена под капотом работают по другому и связано это с общей архитектурой CPython и его особенностью что все есть объект.</p>
<h4>Проверка тождественности is</h4>
<p>Оператор тождественности <code>is</code> сравнивает размещение двух объектов в памяти. Пример:</p>
<pre>c = 100<br>a = c<br>b = c<br><br>x = a <strong>is</strong> b<br><strong>print</strong>(x) # True<br><br>x = a+1 <strong>is</strong> b+1<br><strong>print</strong>(x) # True</pre>
<p>В обоих случаях будет True, так как адреса полученных объектов:</p>
<pre>print(id(c)) # 0001<br>print(id(a)) # 0001<br>print(id(b)) # 0001</pre>
<pre>print(id(a+1)) # 0010<br>print(id(b+1)) # 0010</pre>
<p>Немного модифицируем пример и вместо 100 просто пишем 300.</p>
<blockquote><p>&#8212; триста!</p></blockquote>
<blockquote><p>&#8212; Что триста?</p></blockquote>
<blockquote><p>&#8212; <a href="https://geekjob.ru/vacancies" target="_blank" rel="noopener noreferrer">Зарплата программиста</a>!</p></blockquote>
<pre>c = 300<br>a = c<br>b = c<br><br>x = a <strong>is</strong> b # True<br><br>x = a+1 <strong>is</strong> b+1 #False</pre>
<p>И вот тут нежданчик, как так?</p>
<h4><strong>Кеширование небольших чисел в CPython</strong></h4>
<p>Оказывается в Python целые числа от -5 до 256 имеют заранее выделенные участки в памяти. Когда выполняется какая-либо операция и ее результатом является число из этого промежутка, т.е. вы получаете PyObject со значением из этого выделенного участка.</p>
<p>Эти объекты ссылаются на адреса, выделенные и закешированные под них. Это справедливо для любых значений, которые приводятся к целым числам этого диапазона. Можно завести число в двоичном или hex формате— кеширование будет работать.</p>
<p>Но если вы используете целые числа не из этого промежутка, вы получите новый объект со своим адресом, но есть нюанс: числа вне кешированного диапазона интерпретатор тоже будет пытаться оптимизировать, если они находятся в одной строке или одном файле:</p>
<pre><strong>&gt; cat a.py</strong></pre>
<pre>c = 300<br>a = c<br>b = c<br><br>print(<strong>id</strong>(c)) # 0001<br>print(<strong>id</strong>(a)) # 0001<br>print(<strong>id</strong>(b)) # 0001</pre>
<p>А если:</p>
<pre><strong>&gt; cat a.py</strong></pre>
<pre><strong>from</strong> x <strong>import</strong> a<br><br>print(a <strong>is</strong> 300) # False<br>print(<strong>id</strong>(300)) # 0001<br>print(<strong>id</strong>(a)) # 0010</pre>
<p>Если вам нужно кеширование в интерактивном интерпретаторе, то вы можете писать все в одну строку:</p>
<pre>Python 3.8.1 [Clang 6.0 (clang-600.0.57)] on darwin<br>&gt;&gt;&gt;<br><strong>&gt;&gt;&gt; a = 300<br>&gt;&gt;&gt; b = 300<br>&gt;&gt;&gt; a is b<br>False</strong></pre>
<pre>Но:<br><strong>&gt;&gt;&gt; a=300; b=300<br>&gt;&gt;&gt; a is b<br>True</strong></pre>
<p>Итого, запоминаем: небольшие числа в Python хранятся не так, как большие и они заранее закешированы в памяти. Числа — это объекты со всеми вытекающими и они имеют свои адреса. Есть нюансы где и как инициализирован объект (в 1м файле, на 1й строке и т.д.) — от этого будет зависеть адрес.</p>
<h4>Задачка с собеседования</h4>
<p>Недавно, на собеседовании встретил такую задачку:</p>
<pre><strong>def</strong> foo(x):<br><strong>if</strong> x + 1 <strong>is</strong> 1 + x:<br>        print(0)<br><strong>elif</strong> x + 2 <strong>is</strong> not 2 + x:<br>        print(0)<br><strong>else</strong>:<br>        print(1)</pre>
<pre>foo(???) # чтобы напечатал 1 ?</pre>
<p>Простой ответ: -7. Зная выше перечисленный материал вы сможете легко понять почему так. Эту задачу можно решить еще несколькими способами, например через перегрузку операторов, но собеседующий специалист ждал именно этого ответа, как оказалось, с объяснением вот этих самых подробностей.</p>
<p>P.S.: Продолжайте смеяться над JS и PHP ?</p>

<!--kg-card-end: html-->


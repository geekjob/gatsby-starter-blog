---
title: "Случайные числа не случайны"
date: "2018-02-27T16:17:17.00Z"
description: "Как создать генератор случайных чисел на JS и предсказать Math.random()    Вы когда-нибудь задумывались, как работает Math.rando"
---

<!--kg-card-begin: html--><h4>Как создать генератор случайных чисел на JS и предсказать Math.random()</h4>
<figure>
<p><img data-width="660" data-height="371" src="https://cdn-images-1.medium.com/max/800/1*WgROsTKa6diRYTG5K0R5mw.jpeg"><br />
</figure>
<p>Вы когда-нибудь задумывались, как работает Math.random()? Что такое случайное число и как оно получается? А представьте вопрос на собеседовании — напишите свой генератор случайных чисел в пару строк кода. И так, что же это такое, случайность и возможно ли ее предсказать.</p>
<h4>Генератор псевдослучайных чисел и генератор случайных чисел</h4>
<p>Для того, чтобы получить что-то случайное, нам нужен источник энтропии, источник некого хаоса из который мы будем использовать для генерации случайности.</p>
<p>Этот источник используется для накопления энтропии с последующим получением из неё начального значения (initial value, seed), которое необходимо генераторам случайных чисел (ГСЧ) для формирования случайных чисел.</p>
<p>Генератор ПсевдоСлучайных Чисел использует единственное начальное значение, откуда и следует его псевдослучайность, в то время как Генератор Случайных Чисел всегда формирует случайное число, имея в начале высококачественную случайную величину, которая берется из различных источников энтропии.</p>
<blockquote><p>Энтропия — это мера беспорядка. Информационная энтропия — мера неопределённости или непредсказуемости информации.</p></blockquote>
<p>Выходит, что чтобы создать псевдослучайную последовательность нам нужен алгоритм, который будет генерить некоторую последовательность на основании определенной формулы. Но такую последовательность можно будет предсказать. Тем не менее, давайте пофантазируем, как бы могли написать свой генератор случайных чисел, если бы у нас не было Math.random()</p>
<p>ГПСЧ имеет некоторый алгоритм, который можно воспроизвести.<br />ГСЧ — это получение чисел полностью из какого либо шума, возможность просчитать который стремится к нулю. При этом в ГСЧ есть определенные алгоритмы для выравнивания распределения.</p>
<h3>Придумываем алгоритм ГПСЧ</h3>
<blockquote><p>Генератор псевдослучайных чисел (ГПСЧ, англ. pseudorandom number generator, PRNG) — алгоритм, порождающий последовательность чисел, элементы которой почти независимы друг от друга и подчиняются заданному распределению (обычно равномерному).</p></blockquote>
<p>Мы можем взять последовательность каких-то чисел и брать от них модуль числа. Самый простой пример, который приходит в голову. Нам нужно подумать, какую последовательность взять и модуль от чего. Если просто в лоб от 0 до N и модуль 2, то получится генератор 1 и 0:</p>
<pre><strong>function</strong>* rand() {<br><strong>const</strong> n = 100;<br><strong>const</strong> mod = 2;<br>  let i = 0;<br><strong>while</strong> (<strong>true</strong>) {<br><strong>yield</strong> i % mod;<br><strong>if</strong> (i++ &gt; n) i = 0;<br>  }<br>}</pre>
<pre><strong>let</strong> i = 0;<br><strong>for</strong> (<strong>let</strong> x <strong>of</strong> rand()) {<br><strong>if</strong> (i++ &gt; 100) <strong>break</strong>;<br><strong>console</strong>.log(x);<br>}</pre>
<p>Эта функция генерит нам последовательность 01010101010101… и назвать ее даже псевдослучайной никак нельзя. Чтобы генератор был случайным, он должен проходить <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82_%D0%BD%D0%B0_%D1%81%D0%BB%D0%B5%D0%B4%D1%83%D1%8E%D1%89%D0%B8%D0%B9_%D0%B1%D0%B8%D1%82" target="_blank" rel="noopener noreferrer">тест на следующий бит</a>. Но у нас не стоит такой задачи. Тем не менее даже без всяких тестов мы можем предсказать следующую последовательность, значит такой алгоритм в лоб не подходит, но мы в нужном направлении.</p>
<p>А что если взять какую-то известную, но нелинейную последовательность, например число PI. А в качестве значения для модуля будем брать не 2, а что-то другое. Можно даже подумать на тему меняющегося значения модуля. Последовательность цифр в числе Pi считается случайной. Генератор может работать, используя числа Пи, начиная с какой-то неизвестной точки. Пример такого алгоритма, с последовательностью на базе PI и с изменяемым модулем:</p>
<pre><strong>const</strong> vector = [...<strong>Math</strong>.<strong>PI</strong>.toFixed(48).replace('.','')];</pre>
<pre><strong>function</strong>* rand() {<br><strong>for</strong> (<strong>let</strong> i=3; i&lt;1000; i++) {<br><strong>if</strong> (i &gt; 99) i = 2;<br><strong>for</strong> (let n=0; n&lt;vector.length; n++) {<br><strong>yield</strong> (vector[n] % i);<br>    }<br>  }<br>}</pre>
<p>Но в JS число PI можно вывести только до 48 знака и не более. Поэтому предсказать такую последовательность все так же легко и каждый запуск такого генератора будет выдавать всегда одни и те же числа. Но наш генератор уже стал показывать числа от 0 до 9. Кстати, так выглядит распределение по выпадению чисел при 10000 итерациях:</p>
<pre>0: 394<br>1: 2026<br>2: 304<br>3: 845<br>4: 806<br>5: 1738<br>6: 950<br>7: 935<br>8: 736<br>9: 1267</pre>
<p>Распределение очень неравномерное, но мы получим генератор чисел от 0 до 9.</p>
<p>Мы можем взять не число Pi, а время в числовом представлении и это число рассматривать как последовательность цифр, причем для того, чтобы каждый раз последовательность не повторялась, мы будем считывать ее с конца. Итого наш алгоритм нашего ГПСЧ будет выглядеть так:</p>
<pre><strong>function</strong>* rand() {<br><strong>let</strong> vector = [...(+<strong>new</strong> Date)+''].reverse();<br><strong>let</strong> i=2;<br><strong>while</strong> (true) {<br><strong>if</strong> (i++ &gt; 99) i = 2;<br><strong>let</strong> n=-1;<br><strong>while</strong> (++n &lt; vector.length) {<br><strong>yield</strong> (vector[n] % i);<br>    }<br>    vector = [...(+<strong>new</strong> Date)+''].reverse();<br>  }<br>}</pre>
<pre>// TEST:<br><strong>let</strong> i = 0;<br><strong>let</strong> t = {};<br><strong>for</strong> (<strong>let</strong> x of rand()) {<br><strong>if</strong> (i++ &gt; 100000) break;<br>  ((x in t) ? (t[x]++) : (t[x] = 1));<br>}</pre>
<pre><strong>console</strong>.log(t)</pre>
<p>Вот это уже похоже на генератор псевдослучайных чисел. И тот же Math.random() — это ГПСЧ, про него мы поговорим чуть позже. При этом у нас каждый раз первое число получается разным.</p>
<p>Собственно на этих простых примерах можно понять как работают более сложные генераторы случайных числе. И есть даже готовые алгоритмы. Для примера разберем один из них — это Линейный конгруэнтный ГПСЧ(LCPRNG).</p>
<h3>Линейный конгруэнтный ГПСЧ</h3>
<p>Линейный конгруэнтный ГПСЧ(LCPRNG) — это распространённый метод для генерации псевдослучайных чисел. Он не обладает криптографической стойкостью. Этот метод заключается в вычислении членов линейной рекуррентной последовательности по модулю некоторого натурального числа m, задаваемой следующей формулой:</p>
<figure>
<p><img data-width="241" data-height="22" src="https://cdn-images-1.medium.com/max/800/1*g5zt45LB5aiZgo-sG7nDvA.png"><br />
</figure>
<p>где a(multiplier), c(addend), m(mask) — некоторые целочисленные коэффициенты. Получаемая последовательность зависит от выбора стартового числа — т.е. seed. При разных значениях seed получаются различные последовательности случайных чисел. Пример реализации такого алгоритма на JavaScript:</p>
<pre><strong>const</strong> a = 45;<br><strong>const</strong> c = 21;<br><strong>const</strong> m = 67;<br><strong>var</strong> seed = 2;</pre>
<pre><strong>const</strong> rand = () =&gt; seed = (a * seed + c) % m;</pre>
<pre><strong>for</strong>(<strong>let</strong> i=0; i&lt;30; i++)<br><strong>console</strong>.log( rand() )<br><br></pre>
<p>Многие языки программирования используют LСPRNG (но не именно такой алгоритм(!)).</p>
<p>Как говорилось выше, такую последовательность можно предсказать. Так зачем нам ГПСЧ? Если говорить про безопасность, то ГПСЧ — это проблема. Если говорить про другие задачи, то эти свойства — могут сыграть в плюс. Например для различных спец эффектов и анимаций графики может понадобиться частый вызов random. И вот тут важны распределение значений и перформанс! Секурные алгоритмы не могут похвастать скоростью работы.</p>
<p>Еще одно свойство — воспроизводимость. Некоторые реализации позволяют задать seed, и это очень полезно, если последовательность должна повторяться. Воспроизведение нужно в тестах, например. И еще много других вещей существует, для которых не нужен безопасный ГСЧ.</p>
<h3>Как устроен Math.random()</h3>
<blockquote><p>Метод <code><strong><em>Math.random()</em></strong></code> возвращает псевдослучайное число с плавающей запятой из диапазона <code><em>[0, 1)</em></code>, то есть, от 0 (включительно) до 1 (но не включая 1), которое затем можно отмасштабировать до нужного диапазона. Реализация сама выбирает начальное зерно для алгоритма генерации случайных чисел; оно не может быть выбрано или сброшено пользователем.</p></blockquote>
<p>Как устроен алгоритм Math.random() — интересный вопрос. До недавнего времени, а именно до 49 Chrome использовался алгоритм MWC1616:</p>
<pre><strong>uint32_t</strong> state0 = 1;<br><strong>uint32_t</strong> state1 = 2;<br><strong>uint32_t</strong> mwc1616() {<br>   state0 = 18030 * (state0 &amp; 0xffff) + (state0 &gt;&gt; 16);<br>   state1 = 30903 * (state1 &amp; 0xffff) + (state1 &gt;&gt; 16);<br><strong>return</strong> (state0 &lt;&lt; 16) + (state1 &amp; 0xffff);<br>}</pre>
<p>Именно этот алгоритм генерит нам последовательность псевдослучайных чисел в промежутке между 0 и 1.</p>
<p><strong>UPD</strong></p>
<p>Исправил ошибку в алгоритме MWC1616 (пропущенные скобки). Эта же ошибка повторяется и в статье <a href="https://v8project.blogspot.ru/2015/12/theres-mathrandom-and-then-theres.html" target="_blank" rel="noopener noreferrer">https://v8project.blogspot.ru/2015/12/theres-mathrandom-and-then-theres.html</a></p>
<p>Но если взглянуть в <a href="https://github.com/adblockplus/v8-googlesource/blob/chromium/2416/src/math.js#L135" target="_blank" rel="noopener noreferrer">https://github.com/adblockplus/v8-googlesource/blob/chromium/2416/src/math.js#L135</a></p>
<p>то видим, что должны быть скобки:</p>
<pre><strong>return</strong> <strong>(</strong><em>state0 &lt;&lt; 16</em><strong>)</strong> + (state1 &amp; 0xffff);</pre>
<h4>Предсказываем Math.random()</h4>
<p>Чем это было чревато? Есть такой квест: <a href="https://alf.nu/ReturnTrue" target="_blank" rel="noopener noreferrer">https://alf.nu/ReturnTrue</a></p>
<p>В нем есть задача:</p>
<pre>{<br><strong>let</strong> rand = <strong>Math</strong>.random();<br><strong>function</strong> random4(x) {<br><strong>return</strong> rand === x;<br>	}<br>}<br><br>random4(???)</pre>
<p>Что нужно вписать вместо вопросов, чтобы функция вернула true? Кажется что это невозможно. Но, это возможно, если вы заглядывали в спеку и видели алгоритм ГПСЧ V8. Решение этой задачи в свое время мне показал <a href="https://twitter.com/rdvornov" target="_blank" rel="noopener noreferrer">Роман Дворнов</a>:</p>
<pre><strong>random4</strong>(function(){var A=18030,B=36969,F=65535,Z=16,M=Math,I=M.imul,c=M.random,M=M.pow(2,32),k,d,g=c()*M,h=c()*M;for(k=0;F^k&amp;&amp;(c=I(A,g&gt;&gt;&gt;Z)+k++)&amp;F^h&gt;&gt;&gt;Z;);for(k=0;F^k&amp;&amp;(d=I(B,g&amp;F)+k++)&amp;F^h&amp;F;);for(k=2;k—;g=c&lt;&lt;Z|d&amp;F)c=c/A|c%A&lt;&lt;Z,d=d/B|d%B&lt;&lt;Z;return(g&lt;0?g+M:g)/M}())</pre>
<p>Этот код работал в 70% случаев для Chrome &lt; 49 и Node.js &lt; 5. Рома Дворнов, как всегда, показал чудеса магии, которая не что иное, как глубокое понимание внутренних механизмов браузеров. Я все жду, когда Роман сделает доклад на основе этих событий или напишет более подробную статью.</p>
<p>Что здесь происходит? Все дело в том, что алгоритм можно предсказать. Чтобы это было нагляднее, можно сгенерировать картинку случайных пикселей. На сайте <a href="https://bl.ocks.org/mmalone/bf59aa2e44c44dde78ac" target="_blank" rel="noopener noreferrer">https://bl.ocks.org/mmalone/bf59aa2e44c44dde78ac</a></p>
<p>есть такой генератор. Вот что было, когда в браузере был алгоритм MWC1616:</p>
<figure>
<p><img data-width="1892" data-height="1160" src="https://cdn-images-1.medium.com/max/800/1*YjKkvUjkUsul19A3fyFScw.png"><br />
</figure>
<p>Видите эти равномерности на левом слайде? Изображение показывает проблему с распределением значений. На картинке слева видно, что значения местами сильно группируются, а местами выпадают большие фрагменты. Как следствие — числа можно предсказать.</p>
<p>Выходит что мы можем отреверсить Math.random() и предсказать, какое было загадано число на основе того, что получили в данный момент времени. Для этого получаем два значения через Math.random(). Затем вычисляем внутреннее состояние по этим значениям. Имея внутреннее состояние можем предсказывать следующие значения Math.random() при этом не меняя внутреннее состояние. Меняем код так так, чтобы вместо следующего возвращалось предыдущее значение. Собственно все это и описано в коде-решении для задачи random4. Но потом алгоритм изменили (подробности читайте в спеке). Его можно будет сломать, как только у нас в JS появится нормальная работа с 64 битными числами. Но это уже будет другая история.</p>
<p>Новый алгоритм выглядит так:</p>
<pre><strong>uint64_t</strong> state0 = 1;<br><strong>uint64_t</strong> state1 = 2;<br><strong>uint64_t</strong> xorshift128plus() {<br><strong>uint64_t</strong> s1 = state0;<br><strong>uint64_t</strong> s0 = state1;<br>   state0 = s0;<br>   s1 ^= s1 &lt;&lt; 23;<br>   s1 ^= s1 &gt;&gt; 17;<br>   s1 ^= s0;<br>   s1 ^= s0 &gt;&gt; 26;<br>   state1 = s1;<br><strong>return</strong> state0 + state1;<br>}</pre>
<p>Его все так же можно будет просчитать и предсказать. Но пока у нас нет “длинной математики” в JS. Можно попробовать через TypedArray сделать или использовать специальные библиотеки. Возможно кто-то однажды снова напишет предсказатель. Возможно это будешь ты, читатель. Кто знает ?</p>
<h3><code>Сrypto Random Values</code></h3>
<p>Метод <code>Math.random()</code> не предоставляет криптографически стойкие случайные числа. Не используйте его ни для чего, связанного с безопасностью. Вместо него используйте Web Crypto API (API криптографии в вебе) и более точный метод <code>window.crypto.getRandomValues()</code>.</p>
<p>Пример генерации случайного числа:</p>
<pre><strong>let</strong> [rvalue] = <strong>crypto</strong>.<strong>getRandomValues</strong>(<strong>new</strong> <strong>Uint8Array</strong>(1));<br><strong>console</strong>.log( rvalue )</pre>
<p>Но, в отличие от ГПСЧ Math.random(), этот метод очень ресурсоемкий. Дело в том, что данный генератор использует системные вызовы в ОС, чтобы получить доступ к источникам энтропии (мак адрес, цпу, температуре, etc…).</p>
<hr>
<h3>Материалы про Math.random()</h3>
<p>Больше про random в спецификации:</p>
<p><a href="https://v8project.blogspot.ru/2015/12/theres-mathrandom-and-then-theres.html">https://v8project.blogspot.ru/2015/12/theres-mathrandom-and-then-theres.html</a></p>
<p>Хорошая статья про работу рандомайзера</p>
<p><a href="https://v8project.blogspot.ru/2015/12/theres-mathrandom-and-then-theres.html">https://v8project.blogspot.ru/2015/12/theres-mathrandom-and-then-theres.html</a></p>
<p>Пример реализации предсказателя с Math.random()</p>
<p><a href="https://gist.github.com/fta2012/57f2c48702ac1e6fe99b#file-replicatedrandomchrome-js" target="_blank" rel="noopener noreferrer">https://gist.github.com/fta2012/57f2c48702ac1e6fe99b#file-replicatedrandomchrome-js</a></p>
<hr>
<p><strong>Кстати, следить за обновлениями и прочими материалами от меня можно в телеграм канале: </strong><a href="https://web.telegram.org/#/im?p=@prowebit" target="_blank" rel="noopener noreferrer"><strong>@prowebit</strong></a></p>
<p><strong>В этом канале публикую не только статьи из этого блога, но и различные новости и мысли. Подписывайтесь ?</strong></p>
<!--kg-card-end: html-->


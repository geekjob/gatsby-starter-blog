---
title: "Способ получить конфиг из Etcd и передать его в Nodejs сервер"
date: "2016-08-03T11:28:31.00Z"
description: "Прокидываем данные через окружение При разработке проекта на сервисной архитектуре встает вопрос пробрасывания различных парамет"
---

<!--kg-card-begin: html--><h4>Прокидываем данные через окружение</h4>
<p>При разработке проекта на сервисной архитектуре встает вопрос пробрасывания различных параметров и конфигураций. На сегодня у меня есть проект со следующей SOA (Service Oriented Architecture) архитектурой. Есть четкое разделение Frontend и Backend. Frontend сервер представляет из себя связку Nginx + Nodejs. Все это, вместе с кодом приложения собирается в Docker контейнер. Frontend серверу нужно сообщать о местонахождении REST API сервиса. Можно конечно зафиксировать значения и вшить их в код, поставив различные условия. Но есть способ лучше — использовать Etcd.</p>
<blockquote><p>Etcd — это распределенная система хранения конфигураций.</p></blockquote>
<p>И так, у нас есть package.json следующего содержания:</p>
<p><a href="https://gist.github.com/frontdevops/0230bcde1b8c2001d669ff494baca532">https://gist.github.com/frontdevops/0230bcde1b8c2001d669ff494baca532</a></p>
<p>В случае запуска в dev режиме, мы просто пробрасываем переменные окружения через shell:</p>
<pre><em>API_HOST='http://localhost/' npm run dev</em></pre>
<p>В случае если это production версия, которая запускается внутри Docker контейнера, то все эти переменные окружения прописаны в секции <em>betterScript.start-prod.env</em></p>
<blockquote><p>
<strong>better-npm-run </strong>— это просто утилита для более удобного описания переменных окружения внутри package.json.</p></blockquote>
<p>Все отлично, пока у вас не становится больше сред выполнения. К примеру, у вас есть среда разработки, далее есть сервер тестирования, после чего код идет на боевой. Т.е. вам нужно уже иметь 3 варианта URL для обращения к REST API. Так же у вас может быть потребность обращаться с сервера Frontend к Beckend, а не только с клиента. И тут вы, конечно, можете гонять все запросы через публичный домен. Но если говорить о сокращении издержек на сетевое взаимодействие и просто, банально, секурность, то лучший способ — это общаться по IP напрямую из контейнера в контейнер.</p>
<p>Я не буду говорить сейчас про установку Etcd сервера, это тема отдельной статьи. Представим что у вас уже есть этот демон, его настроили админы или вы сами и вам предстоит забрать данные и выставить переменные окружения. Я покажу способ получения данных перед запуском сервера, без использования демонов и вотчеров. Мы не будем ставить никакие npm-etcd так как это уже скорее про внедрение в логику приложения, а не про переменные окружения.</p>
<h4>Bash way</h4>
<p><a href="https://gist.github.com/frontdevops/20b8465a633d1bad21ac337c5a4ae7e0">https://gist.github.com/frontdevops/20b8465a633d1bad21ac337c5a4ae7e0</a></p>
<p>Что мы сделали. У нас в контейнер пробрасываются переменные ETCD_HOST и ETCD_PORT. Строки</p>
<pre>${ETCD_HOST:-10.0.100.100}<br>${ETCD_PORT:-80}</pre>
<p>означают, что если вдруг этих переменных не существует, то выставить им дефолтное значение (у вас будут свои адреса и порт).</p>
<p>Далее, вы формируете REST запрос к серверу Etcd. Получить URL можно через Etcd browser. Затем, используя curl, читаем данные, без сохранения в файл и сразу же передаем данные в утилиту jq. Эта утилита позволяет парсить JSON прямо в Bash.</p>
<blockquote><p>jq — утилита для работы с JSON из командной строки. С её помощью можно разбирать, фильтровать, сопоставлять и преобразовывать json-данные.</p></blockquote>
<p>Как выглядит результат запроса к REST API Etcd:</p>
<figure>
<p><img data-width="1206" data-height="594" src="https://cdn-images-1.medium.com/max/800/1*Or6_UjOdmpzuPIyU8ErfMw.png"><br />
</figure>
<p>Чтобы получить доступ к нашему значению, мы прописываем следующий путь в запросе к jq:</p>
<pre>jq '.node.nodes[0].value'|tr -d '"'</pre>
<p>Ну и затем отрезаем лишние кавычки с помощью команды <strong>tr -d</strong>. В итоге получаем чистое значение поля. В таком подходе есть не мало минусов, но он самый простой, как мне кажется.</p>
<p>Что касается получения URL для общения внутри сети между серверами, то вы можете добавить следующую переменную окружения:</p>
<pre>API_URI="http://$(netstat -nr | grep '^0\.0\.0\.0' | awk '{print $2}'):48884"</pre>
<p>Этой строчкой мы вычисляем IP Docker хоста, через который проходят все наши запросы. Но это только для общения во внутренней сети. Порт мы четко фиксируем, так как его вычислять не приходится, он у нас всегда постоянен (как и все порты в наших сервисах).</p>
<h4>А как вы прокидываете свои переменные окружения?</h4>
<p>Предлагаю подискутировать…</p>
<!--kg-card-end: html-->


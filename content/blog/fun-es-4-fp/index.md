---
title: "Fun ES #4: задачки в ФП стиле"
date: "2018-04-12T11:16:58.000Z"
description: "Реализуем map, reduce, filter    С приходом моды на функциональное программирование в JS пришли и вопросы для собеседований по э"
---

<h4>Реализуем map, reduce, filter</h4>

<p>С приходом моды на функциональное программирование в JS пришли и вопросы для собеседований по этой же теме. Логично, если назвался функциональщиком, не желая отвечать на вопросы по ООП, будь добр показать, что ты умеешь в FP. В свое время была мода на NoSQL… Одно могу сказать: прошла и теперь бэкенд разработчиков на собеседовании спрашивают как про NoSQL, так и про SQL. И эти вещи сосуществуют, а не взвимно заменяют друг друга.</p>
<p>Так и с функциональным программированием. Пока это новый тренд. Но в итоге все должно прийти к тому, что ФП и ООП не должны бороться, особенно если у вас язык мультипарадигменный. Они должны дополнять друг друга. И стоит разбираться как в ООП паттернах, так и в ФП.</p>
<p>В этой статье покажу пару вопросов, которые в целом интересны своим подходом. Эти задачи интересны сами по себе даже в отрыве от всяких ФП парадигм.</p>
<h3>Вопрос 1. Рразогрев</h3>
<p>Напишите функции head и tail для массивов. Первая возвращает элемент с индексом 0. Вторая возвращает все элементы массива, кроме нулевого.</p>
<pre><strong>const</strong> arr = [ 1, 2, 3 ];<br><em>// head(arr): 1<br>// tail(arr): [ 2, 3 ]</em></pre>
<p>Прелесть ES6+ в том, что теперь такие задачи легко решаются с помощью деструктуризации без манипуляций через slice, pop и shift.</p>
<p>Без написания функций мы можем решить задачу, почти не написав код:</p>
<pre><strong>const</strong> [ head, ...tail ] = [ 1, 2, 3 ];<br><em>// head: 1<br>// tail: [ 2, 3 ]</em></pre>
<p>Соответственно для решения задачи по условию, нам достаточно обернуть этот код в функцию:</p>
<pre><strong>const</strong> head = ([ head, ...tail ]) <strong>=&gt;</strong> head;<br><strong>const</strong> tail = ([ head, ...tail ]) <strong>=&gt;</strong> tail;</pre>
<h3>Вопрос 2. Реализуйте функцию map</h3>
<p>Условие: реализовать функцию map избегая итераций (for, while), встроенных функций forEach, map, reduce, filter и им подобным.</p>
<p>Звучит интересно. Если задать уточняющие вопросы про рекурсию: ответ да, рекурсию использовать можно. Вспомнив решение первого вопроса про head и tail, мы можем использовать эти знания и применить такую же технику в нашей реализации. Вариант функции map, отвечающей условиям задачи:</p>
<pre><strong>const</strong> map = ([ head, ...tail ], fn) <strong>=&gt;</strong><br>  tail.length<br>    ? [ fn(head), ...map(tail, fn) ]<br>    : [ fn(head) ]<br>;</pre>
<p>Проверяем:</p>
<pre><strong>const</strong> a = [1,2,3];</pre>
<pre><strong>const</strong> b = map(a, x <strong>=&gt;</strong> x * 2);</pre>
<pre>console.log(b)<br>// [2, 4, 6]</pre>
<p>Все работает корректно.</p>
<h3>Вопрос 3. Реализуйте функцию Reduce</h3>
<p>Условия такие же, как и в задаче про реализацию map. Забавно, но map от reduce отличается очень мало и на первый взгляд может показатья что код одинаковый. Используем все ту же технику и получаем функцию reduce:</p>
<pre><strong>const</strong> reduce = ([ head, ...tail ], fn, initial) =&gt;<br>  tail.length<br>    ? reduce(tail, fn, fn(initial, head))<br>    : fn(initial, head);<br>;</pre>
<p>Тестируем:</p>
<pre><strong>const</strong> a = [1,2,3];<br><strong>const</strong> b = reduce(a, (a,b) =&gt; a+= b, 0);<br>console.log(b)<br>// 6</pre>
<h3>Вопрос 4. Реализуйте функцию filter</h3>
<p>Опять же условия те же. Ну тут уже как с фокусами. Если знаешь хотя бы 2–3 техники, считай знаешь 30% реализации всех фокусов на планете.</p>
<h4>Реализация filter</h4>
<pre><strong>const</strong> filter = ([ head, ...tail ], fn, newHead=void[]) <strong>=&gt;</strong><br>(<br>  (newHead = fn(head) ? [head] : []),<br>  (tail.length<br>    ? [ ...newHead, ...filter(tail, fn) ]<br>    : newHead<br>  )<br>);</pre>
<p>В этих примерах красота и лаконичность кода достигнута благодаря возможностям деструктуризации в JavaScript. </p>



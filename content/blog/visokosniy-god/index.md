---
title: "Високосный год"
date: "2018-02-05T00:37:37.00Z"
description: "Задачки с собеседований JS, PHP, Rust, Python, Go… > Есть всего 2 типа языков программирования: те, на которые люди все время ру"
---

<h4>Задачки с собеседований JS, PHP, Rust, Python, Go…</h4>
<blockquote><p>Есть всего 2 типа языков программирования: те, на которые люди все время ругаются, и те, на которых никто не пишет.</p></blockquote>
<blockquote><p>Bjarne Stroustrup</p></blockquote>

<p>Есть такая задача: определить является ли год високосным. Причем эта задача может встретиться как в работе, так и на собеседовании. На собеседовании она может быть у кого угодно. У человека пишущего на JS, PHP, Python, Ruby, Swift, Go, etc…</p>
<p>Конечно ответ правильный знает не каждый и это нормально. Нормально не все знать. Всезнайка наоборот вызывает подозрение. Обычно смотрят на рассуждения. Но если вы сталкивались в работе с такой задачей, то она явно будет у вас в голове и вы можете рассказать что знаете решение, потому, что… И показать его.</p>
<h4>Решение</h4>
<p>В зависимости от языка, лучшее решение задействовать готовые стандартные методы и функции или подключить библиотеку для работы с временем и вызвать метод, наподобие isLeap (если он существует в вашем инструменте). Ответы подобного рода дают плюс к знанию вашего инструмента и языка. Но вот, например, в мире фронтенда нет готового метода, зато есть есть куча библиотек, с помощью которых можно решить задачу и есть даже целый npm пакет только под эту задачу (я нашел первый попавшийся, но, думаю, их больше одного):</p>
<pre>$ npm install --save leap-year<br>$ vim leapyear.js</pre>
<pre><strong>const</strong> leapYear <strong>=</strong> <strong>require</strong>('leap-year');<br>leapYear(2014); <em>//=&gt; false<br></em>leapYear(2016); <em>//=&gt; true</em></pre>
<p>Вот в данном случае такой ответ вам сыграет в минус, а не в плюс. Это не нативный метод, это отдельный npm пакет, решающий одну маленькую задачу (наподобие лефтпада). Буду называть такие пакеты LeftPad Like пакеты.</p>
<p>Зная как решается задача, я просто категорически против использования пакетов подобного рода. Ну это же просто нонсенс. В составе какой-то либы для работы с датами — это ок, это еще куда ни шло. Но отдельно! Серьезно?</p>
<p>Кстати в этом пакете и есть правильный ответ, но либы бывают разные. В этой он верный, а может попасться и неверная, особенно если человек перепутал григорианский и юлианский календари.</p>
<p>Ну ок, пусть вы пользуетесь библиотекой. А покажите решение без библиотек, может прозвучать следующий вопрос.</p>
<h4>Ликбез</h4>
<blockquote><p>
<strong>В(и|ы)сокосный год</strong>— год в юлианском и григорианском календарях, продолжительность которого равна 366 дням — это на одни сутки больше продолжительности обычного, невисокосного года. <strong>В юлианском календаре високосным годом является каждый 4й год.</strong> <strong>В григорианском календаре из этого правила есть исключения.</strong>
</p></blockquote>
<p>Мы живем по григорианскому календарю (напомню на всякий случай). Високосный год по григорианскому календарю кратен 4, но при этом не кратен 100 либо кратен 400.</p>
<h3>Python</h3>
<p>Если вы питонист, то говорите, что воспользуетесь библиотекой:</p>
<pre><strong>import</strong> calendar<br><strong>print</strong>(calendar.<strong>isleap</strong>(<em>"2018"</em>))</pre>
<p>А затем уже вас просят реализовать свой алгоритм и вы пишите код, похожий на это:</p>
<pre><strong>def</strong> is_leap_year(year):<br><strong>return</strong> year % 4 == 0 <strong>and</strong> (year % 100 != 0 <strong>or</strong> year % 400 == 0)<br><br>year = 2016<br><strong>print</strong>(is_leap_year(year)) # true<br><br>year = 2018<br><strong>print</strong>(is_leap_year(year)) # false</pre>
<h3>PHP</h3>
<p>В PHP есть несколько способов. Пройдемся по порядку. Если знаете алгоритм, то решение ничем не отличается от вышеизложенного. В 2018 году нормальные посоны пишут затипизированный код на PHP7:</p>
<pre>&lt;?php <strong>declare</strong>(strict_types=1);</pre>
<pre><strong>function</strong> is_leap_year(<strong>int</strong> $year) :<strong>bool<br></strong>{<br><strong>return</strong> $year%4 == 0 and (0 != $year%100 or $year%400 == 0);<br>}</pre>
<p>Вы показали умение решить задачу алгоритмически — круто! Но от вас так же ждут ответы с использованием стандартных методов. Например такой:</p>
<pre>&lt;?php <strong>declare</strong>(strict_types=1);</pre>
<pre><strong>function</strong> is_leap_year(<strong>int</strong> $year) :<strong>bool<br></strong>{<br><strong>return</strong> (bool) <strong>date</strong>('L', mktime(0, 0, 0, 1, 1, $year));<br>}</pre>
<p>В данном случае функция <em>date</em> с параметром “L” будет возвращать “1” в случае високосного года и “0” во всех остальных случаях. Причем тип будет string. Скорее всего в работе вы этим способом и пользовались. Еще вариант с использованием встроенного класса DateTime:</p>
<pre><strong>function</strong> is_leap_year(<strong>int</strong> $year) :<strong>bool<br></strong>{<br><strong>return</strong> (bool) DateTime::createFromFormat('Y', (<strong>string</strong>) $year)<br>             -&gt;<strong>format</strong>('L');<br>}</pre>
<h3>JavaScript</h3>
<p>Я не буду повторять код с проверкой через кратность, он такой же как и в PHP. Я покажу интересные нестандартные варианты, которые так же имеют право на жизнь:</p>
<pre><strong>function</strong> isLeapYear(year) {<br><strong>return</strong> <strong>new</strong> Date(year, 1, 29).getDate() === 29<br>}</pre>
<p>Поиграем с FP стилем. Elm style, все дела.В функциональном стиле это пишется как-то так (да простят меня одепты ФП, если я тут не учел каких-то парадигм):</p>
<pre><strong>const</strong> multOf = (n, x) =&gt; x % n == 0;<br><strong>const</strong> multOf4 = x =&gt; multOf(4, x);<br><strong>const</strong> multOf100 = x =&gt; multOf(100, x);<br><strong>const</strong> multOf400 = x =&gt; multOf(400, x);</pre>
<pre><strong>const</strong> isLeapYear = y =&gt; multOf4(y) &amp;&amp; !multOf100(y) || multOf400(y);</pre>
<p>Этот пример мы можем “улучшить” заменив часть</p>
<pre>multOf4(y) <strong>&amp;&amp; !</strong>multOf100(y)</pre>
<p>на XOR:</p>
<pre><strong>const</strong> isLeapYear = y =&gt;<br><strong>Boolean</strong>(<br>       multOf4(y) ^ multOf100(y) || multOf400(y)<br>    )<br>;</pre>
<p>Операция XOR возвращает 1 если левая и правя части различны. Иначе вернет 0.</p>
<p>Этот же пример с XOR можем применить к первоначальному алгоритму, тогда получится как-то так:</p>
<pre><strong>const</strong> isLeapYear = y =&gt; !!(!!(y%4)^(!!(y%1e2)||!!(y%4e2)));</pre>
<p>Но это уже баловство и просто неэффективно. Но выглядит забавно.</p>
<p>И немного магии. По сути это вариант с кратностью, но переписанный с использованием битовых операторов:</p>
<pre><strong>const</strong> isLeapYear = y =&gt; !(y&amp;3||y&amp;15&amp;&amp;!(y%25));</pre>
<p>Ух, красота. Но читается сложно. Это вариант для общего развития и чтобы коллег удивить. Если сможете показать экзаменатору такое решение — есть вероятность что он будет в шоке =)</p>
<p>На практике лучше не использовать того, в чем не разбираетесь. Если владеете битовыми операторами и можете объяснить как это работает — отлично. Если нет — лучше не стоит зубрить, не оценят.</p>
<p>Как всегда с JS получились примеры круче =)</p>
<h3>Rust</h3>
<p>А так можно записать на Rust, ничего необычного:</p>
<pre><strong>fn</strong> is_leap_year(year: i32) -&gt; bool {<br>    year%4 == 0 &amp;&amp; (0 != year%100 || year%400 == 0)<br>}</pre>
<pre><strong>fn</strong> check_leap(year: i32) {<br><strong>let</strong> answ = is_leap_year(year);<br><strong>println!</strong>("{} is leap year? Answer: {}", year, answ);<br>}</pre>
<pre><strong>fn</strong> main() {<br><strong>let</strong> <strong>mut</strong> year = 2016;<br>    check_leap(year);<br><br>    year = 2018;<br>    check_leap(year);<br>}</pre>
<p>Почему показал пример на Rust? Потому, что в 2018 году, когда браузеры позволяют использовать WASM, Rust это наиболее популярный язык для компиляции в WebAssembly. И пора его учить всем тем, кто претендует на звание сеньора помидора веб-разработки с хорошей ЗП.</p>
<p>А еще сам Rust интересен своим поведением. В данном примере я показал его интересную особенность. Rust — это язык, ориентированный на выражения, а смысл точки с запятой отличается от смысла аналогичного символа в других языках с синтаксисом на основе фигурных скобок и точки с запятой. Эти две особенности связаны. Уточню про что говорю примером:</p>
<pre><strong>fn</strong> is_leap_year(year: i32) -&gt; bool {<br>    year%4 == 0 &amp;&amp; (0 != year%100 || year%400 == 0)<br>}</pre>
<pre>// или</pre>
<pre><strong>fn</strong> is_leap_year(year: i32) -&gt; bool {<br><strong>return</strong> year%4 == 0 &amp;&amp; (0 != year%100 || year%400 == 0) <strong>;</strong><br>}</pre>
<p>И неважно на чем вы сейчас пишите. Если вы фулстек разработчик, Rust может вам пригодиться.</p>
<h3>Golang</h3>
<p>Пример на этом языке покажу по двум причинам. Во-первых Go стал альтернативным языком для веб-разработки для бекендеров, кто раньше писал или до сих пор пишет на PHP, Python, Ruby, Nodejs. У нас даже есть вакансии в New.HR где все эти языки пересекаются в той или иной степени. Но не суть.</p>
<p>Во-вторых, я покажу альтернативный способ, который может придти в голову, если знаешь методы стандартных библиотек:</p>
<pre><strong>package</strong> main<br><strong>import</strong> (<br>   "fmt"<br>   "time"<br>)</pre>
<pre><strong>func</strong> IsLeapYear(y int) bool {<br>   year := time.Date(y, time.December, 31, 0, 0, 0, 0, time.Local)<br>   days := year.YearDay()</pre>
<pre>   <strong>if</strong> days &gt; 365 {<br><strong>return</strong> true<br>   } <strong>else</strong> {<br><strong>return</strong> false<br>   }<br>}</pre>
<pre><strong>func</strong> main() {<br><strong>fmt</strong>.Println("2016 is leap year? ", IsLeapYear(2016)) // true<br><strong>fmt</strong>.Println("2018 is leap year? ", IsLeapYear(2018)) // false<br>}</pre>
<h3>Дисклеймер</h3>
<p>Напомню, что я присутствую на множестве технических собеседований совершенно разных специалистов, пишущих на разных языках. Не все задачи, что я описываю — я спрашиваю, если собеседование провожу я. Я делюсь своим опытом. И вот мой личный опыт показывает, что есть пул задач которые одинаковы для всех отраслей IT: от фронтенда и мобильщиков до… До кого угодно.</p>
<p>Что касается задач: любая задача может иметь право быть спрошенной. Вопрос в том, что собеседующий проверяет конкретной задачей, на что смотрит и как реагирует на ответы. А еще надо понимать кому дается задача. Разработчиков уровня сеньор нужно тестировать другими вопросами. Такие задачи хороши для джунов, максимум мидлов.</p>
<p>В данном случае знать как вычисляется високосный год — не обязательный параметр. Но порассуждать на эту тему важно. Как минимум дать вариант ответа, где просто проверять кратность 4м — к этому ответу можно просто придти логически. В итоге нужно рассказать принцип вычисления и дать написать алгоритм, чтобы увидеть каким способом и как человек будет это решать. Умеет ли кандидат работать с рациональными числами (всякое бывает).</p>
<h4>Есть интересные варианты?</h4>
<p>Поделитесь в комментариях. ?</p>
<h3>Откуда взялся високосный год</h3>
<p><iframe title="Как движется Земля  (Vsauce на русском)" width="580" height="326" src="https://www.youtube.com/embed/9afYdKLMylA?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>



---
title: "Еще кейсы для const в ES6+"
date: "2018-04-05T21:43:42.00Z"
description: "Небольшое дополнение В продолжении статьи про const [https://medium.com/@frontman/const-%D0%B2-js-%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5"
---

<!--kg-card-begin: html--><h4>Небольшое дополнение</h4>
<p>В продолжении статьи <a href="https://medium.com/@frontman/const-%D0%B2-js-%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5%D1%82-%D1%81%D0%B2%D0%BE%D1%8E-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%83-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE-b346353d9cce" target="_blank" rel="noopener noreferrer">про const</a> хочется добавить еще примеры использования слова const для создания полной иммутабельности. В принципе иммутабельность можно рассматривать как альтернативу строгой типизации для того, чтобы максимально защитить код. Я за свои 15+ лет видел много кода где переменная терялась или преопределялась повторно или меняла свое значение. И все это были случайные ошибки.</p>
<p>Мы можем использовать const в циклах, если хотим быть уверены что полученное значение из итерируемого объекта будет неизменяемым. Допустим у нас есть некоторый источник данных и мы работаем с каждым элементом в итерации:</p>
<pre><strong>for</strong> (<strong>const</strong> user <strong>of</strong> userList()) {<br><em>    // совершаем сложные манипуляции, много строк кода<br>    // вдруг случайно кто-то написал</em></pre>
<pre>    user = someWtfObject.getUserNameFromUserObj( user )</pre>
<pre><em>    // И вот в таком случае мы сохраним оригинальный объект<br>    // и не позволим его переопределить,<br>    // даже если кто-то очень захотел</em></pre>
<pre>    console.log( user )<br>}</pre>
<p>Но вы можете возразить: ты же сам писал что мы только холдим ссылку на объект, а сам объект остается мутабельным. Как его защитить?</p>
<p>Кстати хороший вопрос, достойный собеседования. Как зафризить объект user в нашем цикле не внося правок в источник? Ведь мы же не можем написать так:</p>
<pre><strong>for</strong> (<strong>const</strong> user <strong>of</strong> userList()) {<br>  user = <strong>Object</strong>.freeze(user);<br>}</pre>
<p>Такой вариант выдаст исключение:</p>
<pre>error TypeError: Assignment to constant variable.</pre>
<p>Как быть? Логично что мы можем определить новый фриз объект, но оригинальный останется мутабельным. Вариант:</p>
<pre><strong>for</strong> (<strong>const</strong> user <strong>of</strong> userList()) {<br><strong>const</strong> User = <strong>Object</strong>.freeze(user);<br>}</pre>
<p>не подходит под условие нашего вопроса. Нам нужно сделать иммутабельным объект user в контексте цикла не прибегая к модификации источника данных и не создавая новых объектов.</p>
<p>В прошлой статье я забыл упомянуть, что Object.freeze умеет замораживать объекты по ссылке. Хоть он и возвращает замороженный объект, тем не менее, можно обойтись без присваивания. Он умеет работать с объектами по ссылке:</p>
<pre><strong>for</strong> (<strong>const</strong> user <strong>of</strong> userList()) {</pre>
<pre>  <strong>Object</strong>.freeze(user);<br>  user.userId = 123; <em>// value will not be changed </em></pre>
<pre>}</pre>
<p>Теперь у нас неизменяемый объект-константа внутри итерации, который живет только внутри итерации и умрет как только итерация закончится (при условии что не останется живых ссылок на эту область видимости).</p>
<p>Про работу c ссылками и про вопросы на собеседованиях по этой теме я расскажу в следующих статьях.</p>
<h4>Вопрос головломка</h4>
<p>Что будет?</p>
<pre><strong>for</strong> (<strong>const</strong> i=0;i&lt;10;i++);</pre>
<p>Задумались? Не буду писать ответ, так как сами сможете его получить, банально вставив код в DevTools. ?</p>

<!--kg-card-end: html-->


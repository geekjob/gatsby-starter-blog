---
title: "Fun JS/PHP #2"
date: "2018-01-20T14:11:14.00Z"
description: "JS versus PHP battle    Сегодня будет небольшой баттл между PHP и JS. Баттл не по скорости и тому, кто круче, а просто пример то"
---

<!--kg-card-begin: html--><h4>JS versus PHP battle</h4>
<figure>
<p><img data-width="1024" data-height="493" src="https://cdn-images-1.medium.com/max/800/1*i_PRj8nBEE-6VDR33jblRg.jpeg"><br />
</figure>
<p>Сегодня будет небольшой баттл между PHP и JS. Баттл не по скорости и тому, кто круче, а просто пример того, как отличаются методы парсинга кода в интерпретаторах JS и PHP на примере одной простой задачки.</p>
<p>Дано:</p>
<pre>var $a, $b;</pre>
<pre>$a = 1;<br>$b = 1;</pre>
<pre>console.log( $a + $a++ );<br>console.log( $b + $b + $b++ );<br>console.log( $a, $b );</pre>
<p>и такой же код на PHP:</p>
<pre>&lt;?php</pre>
<pre>$a = 1;<br>$b = 1;</pre>
<pre>var_dump( $a + $a++ );<br>var_dump( $b + $b + $b++ );<br>var_dump( $a, $b );</pre>
<p>Собственно простой вопрос: что будет выведено?</p>
<p>В целом задачка очевидна вроде бы. Зная как работают операторы и с какой стороны парсит парсер: слева направо или справа налево можно дать точный ответ. Думай как парсер, будь как парсер ?</p>
<h3>Ответы</h3>
<p>Нанчем с JS кода:</p>
<p>Чтение выражения идет слева направо. Изначально $a = 1. После вычисления выражения $a = 2. Итого получаем:</p>
<pre><strong>//            1    1    и после $a = 2</strong><br>console.log( $a + $a++ ); <strong>// = 2</strong></pre>
<pre><strong>//            1    1    1  и после $b = 2</strong><br>console.log( $b + $b + $b++ ); <strong>// = 3</strong></pre>
<pre>console.log( $a, $b ); // 2 , 2</pre>
<p>Это разные выражения и условие</p>
<pre>($a + $a++) !== ($b + $b + $b++)</pre>
<p>истинно. А теперь рассммотрим тот же код на PHP:</p>
<p>Прежде чем пойдем дальше, скажу что условие</p>
<pre>($a + $a++) === ($b + $b + $b++)</pre>
<p>для PHP будет истинно. Внезапно, да?!</p>
<p>(ссылка для проверки во всех актуальных версиях интерпретатора <a href="https://3v4l.org/1ss4E" target="_blank" rel="noopener noreferrer">https://3v4l.org/1ss4E</a>)</p>
<p>Ну давайте разбираться почему.</p>
<pre><strong>//         2    1  и после $a = 2</strong><br>var_dump( $a + $a++ ); <strong>// = 3</strong></pre>
<p>Почему так? Сначала PHP смотрит на правую часть видит что там идет вызов $a и подставляет значение 1, но тут же продолжает вычисление, в результате которого происходит постфиксный инкремент. Теперь $a=2. Когда интерпретатор начинает вычислять левую часть $a уже равен 2 и у нас получается выражение 2 + 1</p>
<p>Что же происходит с $b?</p>
<pre><strong> 1    1    1  и после $b = 2</strong><br>$b + $b + $b++</pre>
<p>В данном случае интерпретатор как бы “сгруппирует” выражения:</p>
<pre>1 операция      2 операция<strong><br>   /          /<br>  1    1        1 и после $b = 2</strong><em><br></em>($b + $b)    + $b++</pre>
<p>Все дело в приоритете операторов. Если идете на собеседование, советую подтянуть знания почитав мануал <a href="http://php.net/manual/ru/language.operators.precedence.php" target="_blank" rel="noopener noreferrer">http://php.net/manual/ru/language.operators.precedence.php</a></p>
<blockquote><p>Если операторы имеют равный приоритет, то будут ли они выполняться справа налево или слева направо определяется их ассоциативностью. К примеру, “-” является лево-ассоциативным оператором. Следовательно <em>1–2–3</em> сгруппируется как <em>(1–2) — 3</em> и пересчитается в <em>-4</em>. С другой стороны “=” — право-ассоциативный оператор, так что <em>$a = $b = $c</em> сгруппируется как <em>$a = ($b = $c)</em>.</p></blockquote>
<blockquote><p>Неассоциативные операторы с одинаковым приоритетом не могут использоваться совместно. К примеру <em>1 &lt; 2 &gt; 1</em> не будет работать в PHP. Выражение <em>1 &lt;= 1 == 1</em>, с другой стороны, будет, поскольку <em>==</em> имеет более низкий приоритет чем <em>&lt;=</em>.</p></blockquote>
<p>И теперь, зная эту особенность, можно играть с группировками и префиксным инкрементом:</p>
<pre>//         <strong>2     2    1</strong><br>var_dump( $b + ($b + $b++) );  // 5<br><strong>//         1    1      2</strong><br>var_dump( $b + $b + ++$b );    // 4<br><strong>//         1    1        2</strong><br>var_dump( ($b + $b) + ++$b );  // 4<br><strong>//         2     2      2</strong><br>var_dump( $b + ($b + ++$b) );  // 6</pre>
<p>В JS все будет более просто и предсказуемее: сначала подстановка, потом вычисление инкремента. В PHP же надо знать порядок группировки.</p>
<h3>UPD</h3>
<p><a href="https://medium.com/u/96b85a933bae" target="_blank" rel="noopener noreferrer">Alexander Karpan</a> в комментарии к статье дал другой способ понять почему так происходит (спасибо за это!). ⇣⇣⇣ Если сдампить опкоды, то можно увидеть как происходят вычисления:</p>
<pre>L8 : T7 = <strong>ADD</strong> CV1(<strong>$b</strong>) CV1(<strong>$b</strong>)<br>L9 : T8 = <strong>POST_INC</strong> CV1(<strong>$b</strong>)<br>L10: T9 = <strong>ADD</strong> T7 T8</pre>
<h3>Итог</h3>
<p>То что в JS не равно</p>
<pre><strong>var</strong> a = 1, b = 1;<br>(a + a++) <strong>!==</strong> (b + b + b++)</pre>
<p>то в PHP еще как равно:</p>
<pre>$a = 1; $b = 1;<br>($a + $a++) <strong>===</strong> ($b + $b + $b++)</pre>
<!--kg-card-end: html-->


---
title: "Поля, атрибуты или свойства?"
date: "2016-12-08T20:23:27.00Z"
description: "Понимая TypeScript и ООП Если вы в прошлом C#/C++ разработчик или пришли в мир JS из Java, то у вас нет проблем в освоении TypeS"
---

<!--kg-card-begin: html--><h4>Понимая TypeScript и ООП</h4>
<p>Если вы в прошлом C#/C++ разработчик или пришли в мир JS из Java, то у вас нет проблем в освоении TypeScript. И уже тем более вы хорошо ориентируетесь в терминологии ООП.</p>
<p>Но если за плечами у вас нет похожего опыта, то, порой, вам сложно общаться с суровыми энтерпрайзными дядьками бекендерами. Сейчас это исправим. И так, что такое поле класса?</p>
<h4>Поле класса</h4>
<p><strong>Поле класса</strong> в ООП мире называется переменная, связанная с классом или объектом. Все данные объекта хранятся в его полях. Доступ к полям осуществляется по их имени. У полей есть альтернативные названия:</p>
<ul>
<li>атрибут класса</li>
<li>переменная-член класса</li>
</ul>
<p>Поля бывают собственные (обычные) и общие для всех объектов (экземпляров (instance’ов)) класса (статические).</p>
<p>По области видимости поля бывают:</p>
<ul>
<li>public — общедоступные</li>
<li>protected —доступуные только для потомков</li>
<li>private — доступные только внутри класса</li>
</ul>
<p>Пример:</p>
<pre>class A {<br><strong>public</strong> <strong>readonly</strong> someNumber :number =  123 ;<br><strong>public</strong> <strong>static</strong>   someString :string = <em>'456'</em>;<br>}</pre>
<pre><strong>let</strong> a :A = new A;<br>a.someNumber = parseInt( A.someString );</pre>
<h4>Свойство класса</h4>
<p><strong>Свойство</strong> — это способ доступа к внутреннему состоянию объекта, имитирующий поле. Обращение к свойству объекта выглядит так же, как и обращение к полю, но, в действительности, реализовано через вызов функции. При попытке задать значение свойства вызывается метод называемый сеттером (setter). А при попытке получить значение свойства — геттер (getter).</p>
<p>Как правило, свойство связано с некоторым внутренним полем объекта. Но свойству вообще может не быть сопоставлена ни одна переменная объекта, хотя пользователь данного объекта имеет дело с ним так, как если бы это было настоящее поле.</p>
<p>Свойства повышают гибкость и безопасность программирования, поскольку, являясь частью публичного интерфейса и позволяют менять внутреннюю реализацию объекта без изменения его свойств.</p>
<p>Свойства облегчают модификацию кода в случаях, когда класс изначально был реализован с нарушением инкапсуляции, а в дальнейшем потребовалось изменить способ доступа к полю.</p>
<p>В JavaScript геттеры и сеттеры задаются ключевыми словами get и set перед объявлением методов.</p>
<p>Примеры свойств в TypeScript:</p>
<pre><strong>class</strong> Foo&lt;T&gt; {</pre>
<pre>    <strong>private</strong> _bar :T | null = null;</pre>
<pre>    <strong>get</strong> bar(): T {<br>        console.log(`Get "bar" value = ${<strong>this</strong>._bar}`);<br>        return <strong>this</strong>._bar;<br>    }</pre>
<pre>    <strong>set</strong> bar(value: T) {<br>        console.log(`Set "bar" value = ${<strong>this</strong>._bar}`);<br><strong>this</strong>._bar = value;<br>    }<br>}</pre>
<pre><strong>let</strong> fooString: Foo&lt;<strong>string</strong>&gt; = new Foo&lt;<strong>string</strong>&gt;();<br>fooString.bar = 'abc';<br>fooString.bar; <em>// вместо console.log(fooString.bar)</em></pre>
<pre><strong>let</strong> fooNumber: Foo&lt;<strong>number</strong>&gt; = new Foo&lt;<strong>number</strong>&gt;();<br>fooNumber.bar = 123;<br>fooNumber.bar;</pre>
<p>Ну вот как-то так все это работает. Хотя фронтендеры могут сказать:</p>
<blockquote><p>— “Да какая разница? Не все ли равно кого мочить?”</p></blockquote>
<blockquote><p><em>(с) 9 рота</em></p></blockquote>
<p>Ну как сказать. Все-таки это фундаментальные основы и терминология призвана выражать четко свои мысли и намерения. Мы же программисты, йопта.</p>
<!--kg-card-end: html-->


---
title: "Тернарный оператор в PHP"
date: "2019-08-05T15:51:30.000Z"
description: "Шпаргалка
Я люблю краткие записи и часто пользуюсь тернарным оператором, особенно в PHP.
Добавление новых 2х вариаций тернарного"
---

<h4>Шпаргалка</h4>
<p>Я люблю краткие записи и часто пользуюсь тернарным оператором, особенно в PHP. Добавление новых 2х вариаций тернарного оператора, таких как:</p>
<ul>
<li>?: — сокращенная запись тернарного оператора</li>
<li>?? — null coalescing оператор</li>
</ul>
<p>добавили приятного удобства, с одной стороны. С другой — я сам лично периодически путаюсь в этих операторах и забываю какой как должен себя повести. Но так же я видел что некоторые отъявленные php-гуру задают вопросы на по этим операторам. Решил немного привести знания в порядок и структурировать их.</p>
<h4>Тернарный оператор</h4>
<p>И так, тернарный оператор в классическом виде это не что иное как:</p>
<pre><strong>&lt;?=</strong> <strong>true</strong> ? 'true' : <strong>false</strong> ? 'yes' : 'no' <strong>?&gt;</strong></pre>
<p>Выглядит вроде бы просто и понятно (или нет?). И такое можно встретить не только на собеседовании, но и в работе. Вопрос — а каков результат?</p>
<p>Если вычислять, то вроде бы по логике должно вывести слово <code>true</code> . Но это не так. Будет выведено <code>yes</code> . Как так?</p>
<p>Все дело в том, что тернарные выражения вычисляются слева направо. Поэтому эту запись более очевидно можно описать так:</p>
<pre><strong>&lt;?=</strong> (<strong>true</strong> ? 'true':<strong>false)</strong> ? 'yes':'no' <strong>?&gt;</strong></pre>
<p>Вы можете видеть, что первое выражение вычисляется в <code>true</code>, которое в свою очередь вычисляется в <code>(bool)true</code>, таким образом возвращая истинную ветвь второго тернарного выражения.</p>
<p>Поэтому если увлекаетесь вложенными тернарными операторами (а я сам один из тех кто любит вложенные тернарные операторы) — то совет: обрамляйте логические блоки явно круглыми скобками, дабы не запутаться. Ну а если у вас корпоративная команда и вас очень много в проекте, то лучше и вовсе все писать явно длинно, используя классические блоки условий. Выглядит, как по мне, не так красиво, зато точно понятно.</p>
<h4>Сокращенная запись тернарного оператора</h4>
<p>Ранее часто в работе можно было видеть такие куски кода:</p>
<pre><em>&lt;?php declare(strict_types=1);</em></pre>
<pre>$getvar_a = $_GET['a'] ? $_GET['a'] : 'default';</pre>
<p>Дабы сократить дублирование кода было решено, что можно убирать дублирующую запись и с версии 5.3 можно стало писать так:</p>
<pre><em>&lt;?php declare(strict_types=1);</em></pre>
<pre>$getvar_a = $_GET['a'] ?: 'default';</pre>
<p>В целом удобно. И так, это всего лишь сокращенная запись тернарного оператора, подчиняющаяся всем правилам обычного тернарного оператора.</p>
<p>Вернемся к задачке с собеседования выше. Немного переформулируем ее так:</p>
<pre><em>&lt;?php declare(strict_types=1);</em></pre>
<pre>// 1:<br>var_dump( true ? true : 1 ? 1 : 'false' );</pre>
<pre>// 2: короткая запись<br>var_dump( true ?: 1 ?: 'false' );</pre>
<p>Что же в итоге будет в первом и втором варианте? Ну вы уже понимаете, что ответ 1го варианта: 1. Логично предположить, что раз короткая запись это эквивалент, то второй вариант будет тоже 1, да? Но это не точно…</p>
<p>В короткой нотации будет ответ true. Добавим скобок, чтобы было понятен процесс обработки:</p>
<pre>// 1:<br>var_dump( (true ? true : 1) ? 1 : 'false' );</pre>
<pre>// 2: короткая запись<br>var_dump( true ?: (1 ?: 'false') );</pre>
<p>Имейте это в виду, если увлекаетесь вложенными тернарниками ?</p>
<p>Возвращаясь к примеру с $_GET, если вдруг <code>$_GET['a']</code> не будет существовать то мы получим предупреждение:</p>
<pre>Notice: Undefined index: a in ...</pre>
<p>Чтобы этого не было нужно было бы предварительно еще проверить наличие переменной или индекса. И вот чтобы это тоже сократить с версии 7 был добавлен null coalescing оператор.</p>
<h4>Null coalescing оператор</h4>
<p>Это еще одна разновидность тернарника, но с проверкой на существование (проверкой на null).</p>
<pre>$getvar_a = $_GET['a'] <strong>?:</strong> 'default';<br>// Notice: Undefined index: a in ...<br>// $getvar_a = 'default'</pre>
<p>В то время как:</p>
<pre>$getvar_a = $_GET['a'] <strong>??</strong> 'default';<br>// all ok<br>// $getvar_a = 'default'</pre>
<pre>// эквивалент<br>$getvar_a = (<strong>isset</strong>($_GET['a']) <strong>&amp;&amp;</strong> $_GET['a']) <strong>?:</strong> 'default';</pre>
<p>В принципе нечего тут объяснять, все просто и понятно. Запомнили и поехали дальше.</p>
<p>Наша задачка с модификациями:</p>
<pre><em>&lt;?php declare(strict_types=1);</em></pre>
<pre>var_dump( true ?? 1 ?? 'false' );</pre>
<p>Отработает так же как и в случае с короткой записью тернарного оператора.</p>
<h4>Замечание</h4>
<p>И на закуску еще одно важное замечание: все эти операторы трактуются как выражения, и их результат — это результат выражения. Это важно знать, если вы хотите вернуть переменную по ссылке:</p>
<pre><em>&lt;?php declare(strict_types=1);</em></pre>
<pre>$obj1 = f();<br>var_dump( $obj1 );<br>// Notice: Only variable references should be returned by reference in ...</pre>
<pre><strong>function</strong> &amp;f(): ?<strong>object</strong> {<br><strong>static</strong> $obj;<br><strong>if</strong> (!$obj) $obj = (<strong>object</strong>) ['foo' =&gt; 123];<br>    //return $obj; // ok<br><strong>return</strong> $obj ?: <strong>null</strong>; // notice<br>}</pre>




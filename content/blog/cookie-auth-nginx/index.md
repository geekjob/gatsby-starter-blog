---
title: "Cookie авторизация в Nginx"
date: "2019-01-17T15:31:47.00Z"
description: "Закрываем test версию сайта от посторонних глаз Типичная задача: есть тестовая версия проекта с публичным доменом. Нужно как-то "
---

<h4>Закрываем test версию сайта от посторонних глаз</h4>
<p>Типичная задача: есть тестовая версия проекта с публичным доменом. Нужно как-то закрыть эту версию. Раньше пользовался банально базовой авторизацией, реализованной через Nginx, до тех пор пока не столкнулся с проблемами использования.</p>
<p><strong>Проблема 1</strong>. Работа с RESTfull API: если вы правильно отдаете все коды HTTP ответов, то вы должны выдавать 401 для неавторизованных пользователей. И тут я столкнулся с конфликтами HTTP ответов, так как если приложение выдает 401, то при использовании базовой авторизации начинают вылезать авторизационные окна, хотя вы уже залогинились.</p>
<p><strong>Проблема 2</strong>. Она точно такая же как и первая, и опять же про конфликты HTTP ответов. Если вы используете сторонние standalone сервисы, а эти сервисы, в свою очередь, реализует авторизацию на стороне приложения используя механизмы Basic Authorization, то опять получаем конфликты.</p>
<p>В итоге перешел на авторизацию через cookie средствами Nginx. Причем если зайти без авторизации то в ответ будет либо 404, либо будет редирект на основной production домен (смотря что вам нужно).</p>
<p>К примеру, основной домен GeekJOB.ru, тогда для тестов есть домены geekjob.pro и geekjob.org. Но чтобы различные поисковики воспринимали эти домены как зеркала, по дефолту делаем редирект на основной домен. А чтобы зайти на эти домены и увидеть ресурс, нужно выставит нужную куку.</p>
<h3>Cookie авторизация на стороне Nginx</h3>
<pre><strong>server</strong> {<br>  ...<br><strong>location</strong> / {<br><strong>if</strong> (<strong>$cookie_access</strong> != <em>"secretkey"</em>) {<br><strong>return</strong> 404;<br>    }<br>  }<br>  ...<br>}</pre>
<p>или</p>
<pre><strong>server</strong> {<br>  server_name geekjob.pro;<br><strong>...<br>  location /</strong> {<br><strong>    if</strong> (<strong>$cookie_access</strong> != <em>"secretkey"</em>) {<br><strong>return</strong> 302 https://geekjob.ru<em>$request_uri</em>;<br>    }<br>    ...<br>  }<br>  ...<br>}</pre>
<p>Таким образом, если не выставлена нужная кука, то посторонний или поисковый бот уйдут на основной ресурс. Самый простой способ через консоль разработчика выполнить:</p>
<pre>document.cookie = 'access=secretkey'</pre>
<h3>User friendly авторизация</h3>
<p>Но объяснять не технарям, что значит выставить куку в браузере не просто. Или если нужно авторизоваться через мобильный браузер, способ выставления куки руками неудобен. Для этого немного модифицируем конфиг и добавляем следующее правило:</p>
<pre><strong>server</strong> {<br>  server_name geekjob.pro;<br><strong>...<br>  location /</strong> {<strong><br>    if</strong> (<strong>$arg_access</strong>) {<br><strong>add_header</strong> <em>"Set-Cookie" "access=$arg_access"</em>;<br><strong>return</strong> 302 /;<br>    }<br><strong>    if</strong> (<strong>$cookie_access</strong> != <em>"secretkey"</em>) {<br><strong>return</strong> 302 https://geekjob.ru<em>$request_uri</em>;<br>    }<br>    ...<br>  }<br>  ...<br>}</pre>
<p>Мы проверяем есть ли аргумент access в запросе и если есть, то выставляем куку со значением, которое пришло в запросе, после чего делаем редирект на главную без аргументов (поэтому этот блок будет проигнорирован). Проверяем куку и если secretkey совпадают, то обрабатываем дальше запросы иначе просто возвращаем 404 или редиректим (зависит от того, что вам нужно).</p>
<p>Теперь для авторизации нужно передать URL с параметром:</p>
<pre>https://your.domain?access=secretkey</pre>
<p>После чего вы получаете доступ к сайту, который нужно скрыть от посторонних глаз. Такой вот лайфхак.</p>




---
title: "Fun ES #5: перевернуть строку"
date: "2018-08-17T13:49:29.000Z"
description: "Задачки с собеседований. Сборник решений
Давно я не писал ничего из серии разбора задачек. Краткий пост про задачку,
которую уже"
---

<h4>Задачки с собеседований. Сборник решений</h4>
<p>Давно я не писал ничего из серии разбора задачек. Краткий пост про задачку, которую уже просто замусолили. Я не считаю, что эта задача может показать крутость разработчика. Задачка может показать на сколько разработчик давно знаком с языком и на сколько хорошо он ориентируется в API и синтаксисе. Хорошее владение синтаксическими конструкциями еще не говорит о крутости разработчика. Тем не менее такие задачки имеют право на жизнь и их можно давать на собеседовании, просто надо понимать что хочется проверить этой задачей. И так, классика, буквально недавно услышал в очередной раз:</p>
<blockquote><p>Написать функцию, которая переворачивает строку. Например, если мы передаем на вход ‘abcdef’, то возвращает она ‘fedcba’. При решении нельзя использовать циклы (for, while, do, etc…), итерационные методы типа map и forEach.</p></blockquote>
<p>Начнемс.</p>
<h4>Решение 1: Array.prototype.reverse</h4>
<p>Если посмотреть документацию, то в JS уже есть метод reverse у массивов. Строка — это Array like Object. Тем не менее метода reverse в классе String нет. Поэтому мы должны привести строку к массиву, перевернуть и склеить обратно.</p>
<pre><strong>const</strong> strrev = str<strong> =&gt; </strong>str.<strong>split</strong>('').<strong>reverse</strong>().<strong>join</strong>('')</pre>
<p>Изи. Просто изи.</p>
<h4>Решение 2: ES6+</h4>
<p>С приходом стандартов ES6+ у нас появились новые методы для получения массивов. Поэтому мы можем заменить split на Array.from или spread оператор. Выглядит просто чутка моднее:</p>
<pre><strong>const</strong> strrev = str<strong> =&gt; Array.</strong>from(str).<strong>reverse</strong>().<strong>join</strong>('')</pre>
<pre><strong>const</strong> strrev = str<strong> =&gt; [</strong>...str<strong>]</strong>.<strong>reverse</strong>().<strong>join</strong>('')</pre>
<p>Опять же изи.</p>
<h4>Решение 3: редьюсер</h4>
<p>Берем идею с массивом и вместо цепочки reverse + join используем редьюсер:</p>
<pre><strong>const</strong> strrev = str<strong> =&gt; [...</strong>str<strong>].reduce</strong>((str, chr) <strong>=&gt;</strong> chr+str, '')</pre>
<p>Катаем собеседующего как имба к,тун в херстоуне.</p>
<h4>Решение 4: рекурсия</h4>
<p>Вы вдруг слышите: это все хорошо, но теперь представим что больше не можем использовать редьюсеры и сплиты. Что будем делать? Есть варианты? А вы отвечаете: хау ноу вопрос! И даете примерно такое решение:</p>
<pre><strong>function</strong> strrev(str){<br><strong>return</strong> str ? strrev(str.substr(1)) + str[0] : str<br>}</pre>
<p>Что тут происходит? Мы берем первый (с нулевым индексом) элемент и приклеиваем его к концу строки, у которой убираем этот элемент (беря копию строки с позиции +1). И так рекурсивно пока это возможно.</p>
<h3>Модификация задачи: переверните число</h3>
<h4>Решение 1: все что писали уже выше</h4>
<p>Да, все что вам нужно, это привести число к строке, перевернуть и снова привести к числу. Как приводить — вроде бы понятно. Начиная от явных вызовов toString и parseInt, заканчивая автоприведением типов через операторы типа:</p>
<pre>n+''  -&gt; toString<br>str|0 -&gt; parseInt(str)<br>~~str -&gt; parseInt(str)<br>+str  -&gt; parseFloat(str)</pre>
<p>Пример, что может получиться:</p>
<pre><strong>const</strong> numrev = n <strong>=&gt;</strong> +<strong>[</strong>...(n+'')<strong>]</strong>.<strong>reverse</strong>().<strong>join</strong>('')</pre>
<p>Если бы не было ограничений на итераторы, можно было бы переворачивать числа через битовые сдвиги. Но это уже другая история.</p>
<h4>Решение 2: с собеседований НЕфронтендеров</h4>
<p>Эту же задачку любят спрашивать на собеседованиях по С++ и Java, но там ждут совсем другое решение. Можно перевернуть число не приводя его к строке. Для этого есть разные алгоритмы и их рассмотрим прямо в следующем заметке, которую я прямо сейчас пишу (ссылка на нее будет на этом месте).</p>
<p><strong>UPD</strong></p>
<p><a href="https://medium.com/@frontman/fun-es-6-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%B5%D1%80%D0%BD%D1%83%D1%82%D1%8C-%D1%87%D0%B8%D1%81%D0%BB%D0%BE-c3c90be6e9c7">https://medium.com/@frontman/fun-es-6-%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%B5%D1%80%D0%BD%D1%83%D1%82%D1%8C-%D1%87%D0%B8%D1%81%D0%BB%D0%BE-c3c90be6e9c7</a></p>
<h3>Выводы</h3>
<p>Если разработчик решил такую задачу на собеседовании, что это показывает? Хороший вопрос. Если задачки были решены любым способом — уже успех. Если всеми — ну агонь. Только это никак не говорит о квалификации и о том, на сколько успешно будут решены ваши задачи. Более того, если разработчик ни разу не встречал хотя бы пары готовых решений, он может просто не думать в эту сторону. Особенно если он пришел во фронтенд из другого языка, в котором так делать в принципе невозможно и там применялись другие способы. Поэтому я показал тут варианты решений, не столько для тех кто готовится к смене работы, сколько для тех, кому и правда надо перевернуть, но с ходу не пришли идеи, потому что большую часть жизни писали на других языках. Да, в JS так вот можно.</p>
<p>Если бы задача не ограничивалась тем, что нельзя использовать циклы, то мы могли бы говорить про алгоритмы. Но тут речь даже не об алгоритмах, а о том, знаете ли вы нужные методы и можете ли вы их сложить в нужном порядке.</p>
<p>Надо ли давать такие задачи на собеседовании? Почему бы и нет? Это не плохо. Важно не судить кандидата только по такой или таким задачам. Задачка требует время, если человек не знаком и почти не требует время, если человек уже знает ответ. Тратить время на такую задачу — решать вам, товарищи тимлиды.</p>



